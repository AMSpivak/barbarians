#define GLEW_STATIC
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <functional>
#include <utility>
#include <algorithm>
//#define GLM_SWIZZLE_XYZW

#include "glm/glm.hpp"

#include "glm/trigonometric.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtc/type_ptr.hpp"
#include "glm/gtx/rotate_vector.hpp"

#include "gl_physics.h"
#include "gl_game_state_dungeon.h"

#include "loader.h"
#include "engine_settings.h"





GlGameStateDungeon::GlGameStateDungeon(std::map<const std::string,GLuint> &shader_map,
                                    std::map<std::string,std::shared_ptr<glRenderTarget>> & render_target_map,
                                    GLResourcesManager &resources_manager,
                                    size_t screen_width,
                                    size_t screen_height):
                                                        IGlGameState(shader_map,resources_manager,screen_width,screen_height)
                                                        ,m_render_target_map(render_target_map)
                                                        ,m_antialiase_enabled(true)
                                                        ,now_frame(91)
                                                        ,key_angle(0.0f)
{
    m_gl_text = std::make_shared<GlText16x16>("font3.png",GetResourceManager()->m_texture_atlas,0.1f,0.1f);
    float a_ratio = screen_width;
    a_ratio /= screen_height;
    m_map_browser = new Gl2D::GlMapBrowser(-1,-1,2,2,a_ratio,
                                            GetResourceManager()->m_texture_atlas.Assign("chip1.png"),
                                            GetResourceManager()->m_texture_atlas.Assign("chip1blur.png"),
                                            m_shader_map["sprite2dsimple"]);
    m_map_browser->SetItemAligment(Gl2D::ItemAligment::Center);
    m_map_browser->SetAspectRatioKeeper(Gl2D::AspectRatioKeeper::Minimal);

    glEnable(GL_DEPTH_TEST);
	glEnable(GL_CULL_FACE);

    time = glfwGetTime();
}

GlGameStateDungeon::~GlGameStateDungeon()
{
    delete(m_map_browser);
}




void GlGameStateDungeon::Draw2D(GLuint depth_map)
{
    
    glClear( GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);

    m_map_browser->Draw();

    const float text_size_y = 0.060f;
    const float text_size_x = m_aspect_ratio * text_size_y;

    m_gl_text->SetTextSize(text_size_x,text_size_y); 
    auto shader = m_shader_map["sprite2dsimple"];
    std::stringstream ss;
    ss<< std::fixed<<std::setprecision(1)/*<<EngineSettings::GetEngineSettings() ->GetFPS()<<" FPS;"*/<<" X(mkm):"<<m_map_browser->GetX()*700 <<" Y(mkm):"<<m_map_browser->GetY()*700 <<" Z(mkm):" <<std::setprecision(2)<<m_map_browser->GetFocus() - 0.52f;;
    m_gl_text->DrawString(ss.str(),-1.0f,1.0f - text_size_y*1.2f, shader);
}

void GlGameStateDungeon::Draw()
{
  

    glRenderTargetDeffered &render_target = *(dynamic_cast<glRenderTargetDeffered*>(m_render_target_map["base_deffered"].get()));
    glRenderTarget &final_render_target = *(m_render_target_map["final"].get());
    glRenderTarget &postprocess_render_target = *(m_render_target_map["postprocess"].get());

    size_t width = IGlGameState::m_screen_width;
    size_t height = IGlGameState::m_screen_height;

    glDisable(GL_STENCIL_TEST);
    glDisable(GL_DEPTH_TEST);

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glViewport(0, 0, width, height);
    GLuint current_shader = m_shader_map["fullscreen"];

    glUseProgram(current_shader);


    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, postprocess_render_target.AlbedoMap);
    renderQuad();/**/

    Draw2D(render_target.depthMap);

    glEnable(GL_DEPTH_TEST);


}



void GlGameStateDungeon::PostMessage(const std::string & event_string)
{
    m_messages.push_back(event_string);
}

void GlGameStateDungeon::ProcessMessages()
{
    while (!m_messages.empty())
    {
        m_message_processor.Process(m_messages.front());
        m_messages.pop_front();
    }
}


IGlGameState *  GlGameStateDungeon::Process(std::map <int, bool> &inputs, float joy_x, float joy_y)
{
    glRenderTargetDeffered &render_target = *(dynamic_cast<glRenderTargetDeffered*>(m_render_target_map["base_deffered"].get()));
    


   
    GLuint current_shader;


    double time_now = glfwGetTime();
    //std::cout<<(time_now - time)<<'\n';
    if((time_now - time)>(1.0/30.0))
    {
        processed = true;
        bool moving = inputs[GLFW_KEY_RIGHT]|inputs[GLFW_KEY_DOWN]|inputs[GLFW_KEY_LEFT]|inputs[GLFW_KEY_UP];
        if(moving)
        {
            float x =0;
            float y = 0;

            if(inputs[GLFW_KEY_RIGHT]) x += 0.01f;
            if(inputs[GLFW_KEY_LEFT]) x -= 0.01f;

            if(inputs[GLFW_KEY_DOWN]) y += 0.01f;
            if(inputs[GLFW_KEY_UP]) y -= 0.01f;

            m_map_browser->MoveMap(x,y);      
        }

        if(inputs[GLFW_KEY_LEFT_BRACKET])
        {
            m_map_browser->SetFocus(m_map_browser->GetFocus()+0.01f);
        }

        if(inputs[GLFW_KEY_RIGHT_BRACKET])
        {
            m_map_browser->SetFocus(m_map_browser->GetFocus()-0.01f);            
        }


        if(inputs[GLFW_KEY_LAST+3])
        {
            m_map_browser->SetZoom(2.0f * m_map_browser->GetZoom());
            
            if(m_map_browser->GetZoom()> 16.0f)
                m_map_browser->SetZoom(1.0f);

            inputs[GLFW_KEY_LAST+3] = false;
        }

        ProcessMessages();

        time = time_now;


        
    }
    return this;
}
